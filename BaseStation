#include <SPI.h>
#include <LoRa.h>
#include <math.h>

#define SCK 42
#define MISO 41
#define MOSI 2
#define SS 1
#define rst 5
#define dio0 4


byte localAddress = 0xFF;
int recipient;
String incoming;
byte sender;
byte incomingMsgId;
byte incomingLength;
float lat, lon;
int ID;

unsigned long adjustedRoundTripTime = 0;
const int maxTargets = 10;
TargetInfo targets[maxTargets];
int targetCount = 0;


const double RADIUS_OF_EARTH = 6371000;  // Earth's radius in meters

double haversine(double lat1, double lon1, double lat2, double lon2) {
  double dLat = (lat2 - lat1) * M_PI / 180.0;
  double dLon = (lon2 - lon1) * M_PI / 180.0;

  lat1 = lat1 * M_PI / 180.0;
  lat2 = lat2 * M_PI / 180.0;

  double a = pow(sin(dLat / 2), 2) + pow(sin(dLon / 2), 2) * cos(lat1) * cos(lat2);
  double c = 2 * asin(sqrt(a));
  return RADIUS_OF_EARTH * c;
}


void setup() {
  Serial.begin(115200);
  SPI.begin(SCK, MISO, MOSI, SS);
  Serial.println("LoRa Receiver");
  LoRa.setPins(SS, rst, dio0);

  while (!LoRa.begin(915E6)) {
    Serial.println(".");
    delay(500);
  }
  Serial.println("LoRa Initializing OK!");
}

struct TargetInfo {
  int id;
  float latitude;
  float longitude;
  double distance;
};


void loop() {
}

void onReceive(int packetSize) {
  int recipient;
  int sender;
  byte incomingMsgId;
  int incomingLength;
  float targetLatitude;
  float targetLongitude;
  int targetId;
  unsigned long adjustedRoundTripTime = 0;

  if (packetSize == 0) return;

  recipient = LoRa.read();
  sender = LoRa.read();
  incomingMsgId = LoRa.read();
  incomingLength = LoRa.read();

  String incoming = "";

  while (LoRa.available()) {
    incoming += (char)LoRa.read();
  }

  Serial.print("Message: ");
  Serial.println(incoming);

  if (incoming.startsWith("calibrateResponse:")) {
    int separatorIndex = incoming.indexOf(':');
    int commaIndex = incoming.indexOf(',', separatorIndex + 1);
    int secondCommaIndex = incoming.indexOf(',', commaIndex + 1);

    targetLatitude = incoming.substring(separatorIndex + 1, commaIndex).toFloat();
    targetLongitude = incoming.substring(commaIndex + 1, secondCommaIndex).toFloat();
    targetId = incoming.substring(secondCommaIndex + 1).toInt();

    adjustedRoundTripTime = millis() - lastCalibrateSent;

    double distance = calculateDistance(targetLatitude, targetLongitude, baseLatitude, baseLongitude);
    distance = distance - adjustedRoundTripTime / 1000.0 * speedOfLight;

    // Get the base station's location
    unsigned long locationAcquisitionStartTime = millis();
    getLocation();  // This function should update baseLatitude and baseLongitude
    unsigned long locationAcquisitionTime = millis() - locationAcquisitionStartTime;

    adjustedRoundTripTime = millis() - lastCalibrateSent - locationAcquisitionTime;

    Serial.print("Distance to target ");
    Serial.print(targetId);
    Serial.print(": ");
    Serial.print(distance);
    Serial.println(" meters");

    // Create a new TargetInfo object and populate it with the target data
    TargetInfo newTarget;
    newTarget.id = targetId;
    newTarget.latitude = baseLatitude;
    newTarget.longitude = baseLongitude;
    newTarget.distance = distance;

    // Store the new target information in the array
    if (targetCount < maxTargets) {
      targets[targetCount] = newTarget;
      targetCount++;
    } else {
      Serial.println("Warning: Max targets reached. Ignoring new target.");
    }
  }
}

String getGpsLocation() {
  smartDelay(1000); // Wait for a short time to collect GPS data

  if (gps.location.isValid()) {
    float baseLatitude = gps.location.lat();
    float baseLongitude = gps.location.lng();

    String location = String(baseLatitude, 6) + "," + String(baseLongitude, 6);
    return location;
  } else {
    Serial.println("GPS location is not valid.");
    return "INVALID";
  }
}

// This custom version of delay() ensures that the gps object
// is being "fed".
static void smartDelay(unsigned long ms) {
  unsigned long start = millis();
  do {
    while (hs.available())
      gps.encode(hs.read());
  } while (millis() - start < ms);
}

static void printFloat(float val, bool valid, int len, int prec) {
  if (!valid) {
    while (len-- > 1)
      Serial.print('*');
    Serial.print(' ');
  } else {
    Serial.print(val, prec);
    int vi = abs((int)val);
    int flen = prec + (val < 0.0 ? 2 : 1);  // . and -
    flen += vi >= 1000 ? 4 : vi >= 100 ? 3
                           : vi >= 10  ? 2
                                       : 1;
    for (int i = flen; i < len; ++i)
      Serial.print(' ');
  }
  smartDelay(0);
}

static void printInt(unsigned long val, bool valid, int len) {
  char sz[32] = "*****************";
  if (valid)
    sprintf(sz, "%ld", val);
  sz[len] = 0;
  for (int i = strlen(sz); i < len; ++i)
    sz[i] = ' ';
  if (len > 0)
    sz[len - 1] = ' ';
  Serial.print(sz);
  smartDelay(0);
}

static void printDateTime(TinyGPSDate &d, TinyGPSTime &t) {
  if (!d.isValid()) {
    Serial.print(F("********** "));
  } else {
    char sz[32];
    sprintf(sz, "%02d/%02d/%02d ", d.month(), d.day(), d.year());
    Serial.print(sz);
  }

  if (!t.isValid()) {
    Serial.print(F("******** "));
  } else {
    char sz[32];
    sprintf(sz, "%02d:%02d:%02d ", t.hour(), t.minute(), t.second());
    Serial.print(sz);
  }

  printInt(d.age(), d.isValid(), 5);
  smartDelay(0);
}

static void printStr(const char *str, int len) {
  int slen = strlen(str);
  for (int i = 0; i < len; ++i)
    Serial.print(i < slen ? str[i] : ' ');
  smartDelay(0);
}
