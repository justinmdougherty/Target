#include <SPI.h>
#include <LoRa.h>
#include <TinyGPS++.h>
#include <math.h>

#define SCK 42
#define MISO 41
#define MOSI 2
#define SS 1
#define rst 5
#define dio0 4

const int triggerPin = 14;
const int triggerID = 1;

TinyGPSPlus gps;
#define hs Serial1

byte localAddress = 0xBB;
byte msgCount = 0;

long startTime;
long adjustedRoundTripTime;
float baseLatitude;
float baseLongitude;
long shotTriggerTime;
const int numTargets = 10;
long impactTimes[numTargets] = { 0 };
int impactCount = 0;

const double RADIUS_OF_EARTH = 6371000;

double haversine(double lat1, double lon1, double lat2, double lon2) {
  double dLat = (lat2 - lat1) * M_PI / 180.0;
  double dLon = (lon2 - lon1) * M_PI / 180.0;

  lat1 = lat1 * M_PI / 180.0;
  lat2 = lat2 * M_PI / 180.0;

  double a = pow(sin(dLat / 2), 2) + pow(sin(dLon / 2), 2) * cos(lat1) * cos(lat2);
  double c = 2 * asin(sqrt(a));
  return RADIUS_OF_EARTH * c;
}

void setup() {
  Serial.begin(115200);
  hs.begin(9600);
  SPI.begin(SCK, MISO, MOSI, SS);
  LoRa.setPins(SS, rst, dio0);
  LoRa.begin(915E6);
  LoRa.onReceive(onReceive);
  LoRa.receive();

  pinMode(triggerPin, INPUT_PULLUP);
}

void loop() {
  getLocation();
  readCalibrateTrigger();
  readShotTrigger();
  delay(1000);
}

void getLocation() {
  while (hs.available() > 0) {
    if (gps.encode(hs.read())) {
      if (gps.location.isValid()) {
        baseLatitude = gps.location.lat();
        baseLongitude = gps.location.lng();
      }
    }
  }
}

void readCalibrateTrigger() {
  if (digitalRead(triggerPin) == LOW) {
    startTime = millis();
    sendMessage("calibrate");
  }
}

void readShotTrigger() {
  if (digitalRead(triggerPin) == LOW) {
    shotTriggerTime = millis();
    sendMessage("shotTrigger");
  }
}

void sendMessage(String message) {
  LoRa.beginPacket();
  LoRa.print(message);
  LoRa.endPacket();
}

void onReceive(int packetSize) {
  if (packetSize == 0) return;

  String incoming = "";
  while (LoRa.available()) {
    incoming += (char)LoRa.read();
  }

  Serial.print("Message: ");
  Serial.println(incoming);

  if (incoming.startsWith("calibrateResponse:")) {
    int separator1 = incoming.indexOf(',');
    int separator2 = incoming.lastIndexOf(',');

    float targetLatitude = incoming.substring(16, separator1).toFloat();
    float targetLongitude = incoming.substring(separator1 + 1, separator2).toFloat();
    int targetID = incoming.substring(separator2 + 1).toInt();

    long endTime = millis();
    adjustedRoundTripTime = (endTime - startTime) / 2;

    float distance = haversine(baseLatitude, baseLongitude, targetLatitude, targetLongitude);
    Serial.print("Distance to target ");
    Serial.print("Distance to target ");
    Serial.print(targetID);
    Serial.print(": ");
    Serial.println(distance);

  } else if (incoming.startsWith("shotTriggerResponse:")) {
    int targetID = incoming.substring(18).toInt();
    long endTime = millis();
    long elapsedTime = endTime - shotTriggerTime - adjustedRoundTripTime;

    if (impactCount < numTargets) {
      impactTimes[impactCount] = elapsedTime;
      impactCount++;
    } else {
      for (int i = 0; i < numTargets - 1; i++) {
        impactTimes[i] = impactTimes[i + 1];
      }
      impactTimes[numTargets - 1] = elapsedTime;
    }

    double sum = 0;
    for (int i = 0; i < impactCount; i++) {
      sum += impactTimes[i];
    }
    double average = sum / impactCount;

    Serial.print("Impact time for target ");
    Serial.print(targetID);
    Serial.print(": ");
    Serial.println(elapsedTime);
    Serial.print("Average impact time: ");
    Serial.println(average);
  }
}
